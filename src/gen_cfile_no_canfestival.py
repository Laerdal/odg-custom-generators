from __future__ import annotations
"""Generate C file from a object dictionary node for canfestival."""
"""Based on the original gen_cfile.py from odg"""
#
# Copyright (C) 2022-2024  Svein Seldal, Laerdal Medical AS
# Copyright (C) 2025-2025  Ronald Kaczynski, Laerdal Medical AS
# Copyright (C): Edouard TISSERANT, Francis DUPIN
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
# USA

from generators_common import *
from pathlib import Path
from objdictgen.maps import OD
from objdictgen.typing import NodeProtocol, TPath

FILE_HEADER = """
/* File generated by gen_cfile.py. Should not be modified. */
"""


def generate_file_content(node: NodeProtocol, headerfile: str) -> tuple[str, str, str, str, str]:
    # FIXME: Too many camelCase vars in here
    # pylint: disable=invalid-name


    ctx, listindex, variablelist = setup_c_file_context(node)
    # --------------------------------------------------------------------------
    #        Creation of the mapped variables and object dictionary
    # --------------------------------------------------------------------------

    noCanFestivalDeclarations = ctx.text()
    noCanFestivalDefinitions = ctx.text()

    def add_file_content(header_content, c_content):
        nonlocal noCanFestivalDeclarations
        nonlocal noCanFestivalDefinitions

        if "valueRange_" in typeinfos.ctype:
            ctx["subIndexType"] = "uint8_t"
        elif typeinfos.ctype == "visible_string":
            ctx["subIndexType"] = "char"
        else:
            ctx["subIndexType"] = convert_from_canopen_to_c_type(typeinfos.ctype)

        noCanFestivalDeclarations %= header_content
        noCanFestivalDefinitions %= c_content
        ctx["subIndexType"] = typeinfos.type

    for index in listindex:
        ctx["index"] = index
        entry_infos = node.GetEntryInfos(index)
        params_infos = node.GetParamsEntry(index)
        ctx["EntryName"] = entry_infos["name"]
        values = node.GetEntry(index)

        # Entry type is VAR
        if not isinstance(values, list):
            # FIXME: It is assumed that the type of GetParamsEntry() follows the object type
            #        of GetEntry()
            assert not isinstance(params_infos, list)
            subentry_infos = node.GetSubentryInfos(index, 0)
            typename = node.GetTypeName(subentry_infos["type"])
            typeinfos = ctx.get_valid_type_infos(typename, [values])
            if typename == "DOMAIN" and index in variablelist:
                if not typeinfos.size:
                    raise ValueError(f"Domain variable not initialized, index: 0x{index:04X}, subindex: 0x00")
            ctx["subIndexType"] = typeinfos.type
            if typeinfos.size is not None:
                if params_infos["buffer_size"]:
                    ctx["suffix"] = f"[{params_infos['buffer_size']}]"
                else:
                    ctx["suffix"] = f"[{typeinfos.size}]"
            else:
                ctx["suffix"] = ""
            ctx["value"], ctx["comment"] = compute_value(values, typeinfos.ctype)
            if index in variablelist:
                ctx["name"] = RE_STARTS_WITH_DIGIT.sub(r'_\1', format_name(subentry_infos["name"]))
                add_file_content(
                (
                    "extern {subIndexType} {name}{suffix};"
                    "\t\t/* Mapped at index 0x{index:04X}, subindex 0x00*/\n"
                ),
                (
                    "{subIndexType} {name}{suffix} = {value};"
                    "\t\t/* Mapped at index 0x{index:04X}, subindex 0x00 */\n"
                ))
            values = [values]
        else:
            subentry_infos = node.GetSubentryInfos(index, 0)
            typename = node.GetTypeName(subentry_infos["type"])
            typeinfos = ctx.get_valid_type_infos(typename)
            ctx["value"] = values[0] if index != 0x1003 else 0
            ctx["subIndexType"] = typeinfos.type

            # Entry type is ARRAY
            if entry_infos["struct"] & OD.IdenticalSubindexes:
                subentry_infos = node.GetSubentryInfos(index, 1)
                typename = node.GetTypeName(subentry_infos["type"])
                typeinfos = ctx.get_valid_type_infos(typename, values[1:])
                ctx["subIndexType"] = typeinfos.type
                if typeinfos.size is not None:
                    ctx["suffix"] = f"[{typeinfos.size}]"
                    ctx["type_suffix"] = "*"
                else:
                    ctx["suffix"] = ""
                    ctx["type_suffix"] = ""
                ctx["length"] = values[0]
                if index in variablelist:
                    ctx["name"] = RE_STARTS_WITH_DIGIT.sub(r'_\1', format_name(entry_infos["name"]))
                    ctx["values_count"] = str(len(values) - 1)
                    add_file_content(
                    (
                        "extern {subIndexType} {name}[{values_count}]{suffix};\t\t"
                        "/* Mapped at index 0x{index:04X}, subindex 0x01 - 0x{length:02X} */\n"
                    ),
                    (
                        "{subIndexType} {name}[]{suffix} =\t\t"
                        "/* Mapped at index 0x{index:04X}, subindex 0x01 - 0x{length:02X} */\n  {{\n"
                    ))
                

                    for subindex, value in enumerate(values):
                        sep = ","
                        if subindex > 0:
                            if subindex == len(values) - 1:
                                sep = ""
                            value, comment = compute_value(value, typeinfos.ctype)
                            if len(value) == 2 and typename == "DOMAIN":
                                raise ValueError(
                                    "Domain variable not initialized, "
                                    f"index: 0x{index:04X}, subindex: 0x{subindex:02X}"
                                )
                            noCanFestivalDefinitions += f"    {value}{sep}{comment}\n"
                    noCanFestivalDefinitions += "  };\n"
                else:
                    for subindex, value in enumerate(values):
                        sep = ","
                        if subindex > 0:
                            if subindex == len(values) - 1:
                                sep = ""
                            value, comment = compute_value(value, typeinfos.ctype)
            else:

                ctx["parent"] = RE_STARTS_WITH_DIGIT.sub(r'_\1', format_name(entry_infos["name"]))
                # Entry type is RECORD
                for subindex, value in enumerate(values):
                    ctx["subindex"] = subindex
                    # FIXME: Are there any point in calling this for subindex 0?
                    params_infos = node.GetParamsEntry(index, subindex)
                    # FIXME: Assumed params_info type is coherent with entry_infos["struct"]
                    assert not isinstance(params_infos, list)
                    if subindex > 0:
                        subentry_infos = node.GetSubentryInfos(index, subindex)
                        typename = node.GetTypeName(subentry_infos["type"])
                        typeinfos = ctx.get_valid_type_infos(typename, [values[subindex]])
                        ctx["subIndexType"] = typeinfos.type
                        if typeinfos.size is not None:
                            if params_infos["buffer_size"]:
                                ctx["suffix"] = f"[{params_infos['buffer_size']}]"
                            else:
                                ctx["suffix"] = f"[{typeinfos.size}]"
                        else:
                            ctx["suffix"] = ""
                        ctx["value"], ctx["comment"] = compute_value(value, typeinfos.ctype)
                        ctx["name"] = format_name(subentry_infos["name"])
                        if index in variablelist:
                            add_file_content(
                            (
                                "extern {subIndexType} {parent}_{name}{suffix};\t\t"
                                "/* Mapped at index 0x{index:04X}, subindex 0x{subindex:02X} */\n"
                            ),
                            (
                                "{subIndexType} {parent}_{name}{suffix} = {value};\t\t"
                                "/* Mapped at index 0x{index:04X}, subindex 0x{subindex:02X} */\n"
                            ))

        # Generating Dictionary C++ entry
        for subindex, _ in enumerate(values):
            subentry_infos = node.GetSubentryInfos(index, subindex)
            params_infos = node.GetParamsEntry(index, subindex)
            # FIXME: As subindex is non-zero, params can't be a list
            assert not isinstance(params_infos, list)
            if subindex < len(values) - 1:
                sep = ","
            else:
                sep = ""
            typename = node.GetTypeName(subentry_infos["type"])
            if entry_infos["struct"] & OD.IdenticalSubindexes:
                typeinfos = ctx.get_valid_type_infos(typename, values[1:])
            else:
                typeinfos = ctx.get_valid_type_infos(typename, [values[subindex]])
            if subindex == 0:
                if index == 0x1003:
                    typeinfos = ctx.get_valid_type_infos("valueRange_EMC")
                if entry_infos["struct"] & OD.MultipleSubindexes:
                    name = f"{ctx['NodeName']}_highestSubIndex_obj{ctx['index']:04X}"
                elif index in variablelist:
                    name = format_name(subentry_infos["name"])
                else:
                    name = format_name(f"{ctx['NodeName']}_obj{ctx['index']:04X}")
            elif entry_infos["struct"] & OD.IdenticalSubindexes:
                if index in variablelist:
                    name = f"{format_name(entry_infos['name'])}[{subindex - 1}]"
                else:
                    name = f"{ctx['NodeName']}_obj{ctx['index']:04X}[{subindex - 1}]"
            else:
                if index in variablelist:
                    name = format_name(f"{entry_infos['name']}_{subentry_infos['name']}")
                else:
                    name = (
                        f"{ctx['NodeName']}_obj{ctx['index']:04X}_"
                        f"{format_name(subentry_infos['name'])}"
                    )
            if typeinfos.ctype == "visible_string":
                if params_infos["buffer_size"]:
                    sizeof = str(params_infos["buffer_size"])
                else:
                    value = values[subindex]
                    # FIXME: It should be a str type with visible_string
                    assert isinstance(value, str)
                    sizeof = str(max(len(value), ctx.default_string_size))
            elif typeinfos.ctype == "domain":
                value = values[subindex]
                # FIXME: Value should be string
                assert isinstance(value, str)
                sizeof = str(len(value))
            else:
                sizeof = f"sizeof ({typeinfos.type})"
            params = node.GetParamsEntry(index, subindex)
            # FIXME: As subindex is non-zero, params can't be a list
            assert not isinstance(params, list)
            if params["save"]:
                save = "|TO_BE_SAVE"
            else:
                save = ""
            start_digit = RE_STARTS_WITH_DIGIT.sub(r'_\1', name)

    # --------------------------------------------------------------------------
    #                        Write File Content
    # --------------------------------------------------------------------------

    noCanFestivalFileContent = ctx.text(FILE_HEADER)
    noCanFestivalFileContent += f"""
#include "{headerfile.replace(".", "_no_can_festival.")}"
"""
    noCanFestivalFileContent += """
/**************************************************************************/
/* Declaration of mapped variables                                        */
/**************************************************************************/
"""
    noCanFestivalFileContent += noCanFestivalDefinitions

    # --------------------------------------------------------------------------
    #                      Write Header File Content
    # --------------------------------------------------------------------------

    ctx["file_include_name"] = headerfile.replace(".", "_no_can_festival.").replace(".", "_").upper()
    noCanFestivalHeaderContent = ctx.text(FILE_HEADER)
    noCanFestivalHeaderContent %= """
#ifndef {file_include_name}
#define {file_include_name}

#include <cstdint>

"""
    noCanFestivalHeaderContent += noCanFestivalDeclarations
    noCanFestivalHeaderContent %= "\n#endif // {file_include_name}\n"

    return str(noCanFestivalFileContent), str(noCanFestivalHeaderContent)


# ------------------------------------------------------------------------------
#                             Main Function
# ------------------------------------------------------------------------------

def GenerateFile(filepath: TPath, node: NodeProtocol, pointers_dict=None):
    """Main function to generate the C file from a object dictionary node."""
    filepath = Path(filepath)
    headerpath = filepath.with_suffix(".h")
    noCanFestivalContent, noCanFestivalHeader = generate_file_content(
        node, headerpath.name,
    )

    # Write main .c contents with canfestival types and includes omitted
    filepath = filepath.with_name(f"{filepath.stem}_no_can_festival{filepath.suffix}")
    with open(filepath, "w", encoding="utf-8") as f:
        f.write(noCanFestivalContent)

    # Write header file with canfestival types and includes omitted
    headerpath = headerpath.with_name(f"{headerpath.stem}_no_can_festival{headerpath.suffix}")
    with open(headerpath, "w", encoding="utf-8") as f:
        f.write(noCanFestivalHeader)
