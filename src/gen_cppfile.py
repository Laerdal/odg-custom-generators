"""Generate CPP file containing a modern representation of index/subindex pairs from a object dictionary node for canfestival."""
"""Based on the original gen_cfile.py from odg"""
#
# Copyright (C) 2025-2025  Ronald Kaczynski, Laerdal Medical AS
# Copyright (C): Edouard TISSERANT, Francis DUPIN
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
# USA
#from __future__ import annotations

from pathlib import Path

from objdictgen.maps import OD
from objdictgen.typing import NodeProtocol, TODValue, TPath
from generators_common import *

FILE_HEADER = """
/* File generated by gen_cppfile.py. Should not be modified. */
"""
usingOldOdName = True

def toggle_od_name_version(ctx):
    global usingOldOdName
    if ctx["NodeName"] is None:
        return
    if usingOldOdName:
        ctx["NodeName"] = ctx["NodeName"].replace("OD", "Od")
        usingOldOdName = False
    else:
        ctx["NodeName"] = ctx["NodeName"].replace("Od", "OD")
        usingOldOdName = True

def convert_from_canopen_to_cpp_type(type):
    # Used to convert types when ctype is an illegal non-int value (e.g. valueRange_X)
    type_map = {}
    type_map["boolean"] = "OD::Boolean"
    type_map["int8"] = "OD::Int8"
    type_map["int16"] = "OD::Int16"
    type_map["int32"] = "OD::Int32"
    type_map["int40"] = "OD::Int40"
    type_map["int48"] = "OD::Int48"
    type_map["int56"] = "OD::Int56"
    type_map["int64"] = "OD::UInt64"
    type_map["uint8"] = "OD::UInt8"
    type_map["uint16"] = "OD::UInt16"
    type_map["uint32"] = "OD::UInt32"
    type_map["uint40"] = "OD::UInt40"
    type_map["uint48"] = "OD::UInt48"
    type_map["uint56"] = "OD::UInt56"
    type_map["uint64"] = "OD::UInt64"
    type_map["real32"] = "OD::Real32"
    type_map["real64"] = "OD::Real64"
    type_map["visible_string"] = "OD::VisibleString"
    type_map["octet_string"] = "OD::OctetString"
    if "valueRange_" in type:
        type = "uint8"
    return type_map.get(type, "OD::Unknown")

def generate_file_content(node: NodeProtocol, headerfile: str, pointers_dict=None) -> tuple[str, str, str, str, str]:
    # FIXME: Too many camelCase vars in here
    # pylint: disable=invalid-name

    # Setup the main context to store the data
    ctx, listindex, variablelist, communicationlist, valueRangeContent  = setup_c_file_context(node)

    oldHeaderObjDefinitionContent = ctx.text()
    toggle_od_name_version(ctx)
    headerObjDefinitionContent = ctx.text()
    headerObjDefinitionContent += "\n#include <cstdint>\n"
    headerObjDefinitionContent += "#include <tuple>\n"
    headerObjDefinitionContent += "#include <string>\n"
    headerObjDefinitionContent += "#include \"od_value.h\"\n"
    headerObjDefinitionContent %= """
namespace {NodeName} \n{{
\tstatic constexpr std::string_view OdName = \"{NodeName}\";
"""
    toggle_od_name_version(ctx)
    for index in listindex:
        ctx["index"] = index
        entry_infos = node.GetEntryInfos(index)
        params_infos = node.GetParamsEntry(index)
        ctx["EntryName"] = entry_infos["name"]
        values = node.GetEntry(index)

        # Entry type is VAR
        if not isinstance(values, list):
            # FIXME: It is assumed that the type of GetParamsEntry() follows the object type
            #        of GetEntry()
            assert not isinstance(params_infos, list)
            subentry_infos = node.GetSubentryInfos(index, 0)
            typename = node.GetTypeName(subentry_infos["type"])
            typeinfos = ctx.get_valid_type_infos(typename, [values])
            if typename == "DOMAIN" and index in variablelist:
                if not typeinfos.size:
                    raise ValueError(f"Domain variable not initialized, index: 0x{index:04X}, subindex: 0x00")
            ctx["subIndexType"] = typeinfos.type
            if typeinfos.size is not None:
                if params_infos["buffer_size"]:
                    ctx["suffix"] = f"[{params_infos['buffer_size']}]"
                else:
                    ctx["suffix"] = f"[{typeinfos.size}]"
            else:
                ctx["suffix"] = ""
            ctx["value"], ctx["comment"] = compute_value(values, typeinfos.ctype)
            if index in variablelist:
                ctx["name"] = RE_STARTS_WITH_DIGIT.sub(r'_\1', format_name(subentry_infos["name"]))
            values = [values]
        else:
            subentry_infos = node.GetSubentryInfos(index, 0)
            typename = node.GetTypeName(subentry_infos["type"])
            typeinfos = ctx.get_valid_type_infos(typename)
            ctx["value"] = values[0] if index != 0x1003 else 0
            ctx["subIndexType"] = typeinfos.type

            # Entry type is ARRAY
            if entry_infos["struct"] & OD.IdenticalSubindexes:
                subentry_infos = node.GetSubentryInfos(index, 1)
                typename = node.GetTypeName(subentry_infos["type"])
                typeinfos = ctx.get_valid_type_infos(typename, values[1:])
                ctx["subIndexType"] = typeinfos.type
                if typeinfos.size is not None:
                    ctx["suffix"] = f"[{typeinfos.size}]"
                    ctx["type_suffix"] = "*"
                else:
                    ctx["suffix"] = ""
                    ctx["type_suffix"] = ""
                ctx["length"] = values[0]
                if index in variablelist:
                    ctx["name"] = RE_STARTS_WITH_DIGIT.sub(r'_\1', format_name(entry_infos["name"]))
                    ctx["values_count"] = str(len(values) - 1)

                ctx["parent"] = RE_STARTS_WITH_DIGIT.sub(r'_\1', format_name(entry_infos["name"]))
                # Entry type is RECORD
                for subindex, value in enumerate(values):
                    ctx["subindex"] = subindex
                    # FIXME: Are there any point in calling this for subindex 0?
                    params_infos = node.GetParamsEntry(index, subindex)
                    # FIXME: Assumed params_info type is coherent with entry_infos["struct"]
                    assert not isinstance(params_infos, list)
                    if subindex > 0:
                        subentry_infos = node.GetSubentryInfos(index, subindex)
                        typename = node.GetTypeName(subentry_infos["type"])
                        typeinfos = ctx.get_valid_type_infos(typename, [values[subindex]])
                        ctx["subIndexType"] = typeinfos.type
                        if typeinfos.size is not None:
                            if params_infos["buffer_size"]:
                                ctx["suffix"] = f"[{params_infos['buffer_size']}]"
                            else:
                                ctx["suffix"] = f"[{typeinfos.size}]"
                        else:
                            ctx["suffix"] = ""
                        ctx["value"], ctx["comment"] = compute_value(value, typeinfos.ctype)
                        ctx["name"] = format_name(subentry_infos["name"])

        # write index define
        entryName = f"{RE_NOTW.sub('', ctx['EntryName']).strip()}"
        shortEntryName = entryName.replace(ctx['EntryName'], '')
        typeinfos = ctx.get_valid_type_infos(typename, [values])
        subindex_type = convert_from_canopen_to_cpp_type(typeinfos.ctype)

        structDeclare = f"\tstruct {entryName}\n\t{{\n"
        if len(values) == 1 or entry_infos["struct"] & OD.IdenticalSubindexes:
            structDeclare = f"\tstruct {entryName} : public OD::Value<{subindex_type}>\n\t{{\n"

        toggle_od_name_version(ctx)
        headerObjDefinitionContent += (
            f"{structDeclare}"
            f"\t\tstatic constexpr uint16_t {'' if shortEntryName == entryName else shortEntryName}Index {{{ctx['index']:#04x}}};\n"
            f"\t\tstatic constexpr std::string_view Name = \"{entryName}Index\";\n\n"
        )
        toggle_od_name_version(ctx)

        oldHeaderObjDefinitionContent += (
            f"\n#define {RE_NOTW.sub('_', ctx['NodeName'])}"
            f"_{RE_NOTW.sub('_', ctx['EntryName'])}_Idx {ctx['index']:#04x}\n"
        )

        # write subindex defines
        generateSubIndexArrayComment = True
        for subindex, _ in enumerate(values):
            subentry_infos = node.GetSubentryInfos(index, subindex)
            #there is an issue when setting the typename for each subindex with this OD file - some index and subindex entires have a name which is a canfestival data type (like UNSIGNED8)
            #this OD is unused in the codebase though
            if ctx["NodeName"] != "CANopenDUTOD":
                typename = node.GetTypeName(subentry_infos["type"])
            params_infos = node.GetParamsEntry(index, subindex)
            typeinfos = ctx.get_valid_type_infos(typename, [values])
            subindex_type = convert_from_canopen_to_cpp_type(typeinfos.ctype)
            if not entry_infos["struct"] & OD.IdenticalSubindexes:
                generateSubIndexArrayComment = True
                oldHeaderObjDefinitionContent += (
                    f"#define {RE_NOTW.sub('_', ctx['NodeName'])}"
                    f"_{RE_NOTW.sub('_', ctx['EntryName'])}"
                    f"_{RE_NOTW.sub('_', subentry_infos['name'])}"
                    f"_sIdx {subindex:#04x}"
                )
            
                subindexName = RE_NOTW.sub('', subentry_infos['name'])
                if len(values) > 1:
                    toggle_od_name_version(ctx)
                    headerObjDefinitionContent += (
                        f"\t\tstruct {subindexName}{'Subindex' if subindexName == entryName else ''} : public OD::Value<{subindex_type}>\n"
                        f"\t\t{{\n"
                        f"\t\t\tstatic constexpr auto get()\n\t\t\t{{\n"
                        f"\t\t\t\treturn std::make_tuple(Index, Subindex, OdName, Name, SubIndexName);\n\t\t\t}}\n\n"
                        f"\t\t\tstatic constexpr uint8_t Subindex {{{subindex:#04x}}};\n"
                        f"\t\t\tstatic constexpr std::string_view SubIndexName = \"{subindexName}Subindex\";"
                        f"\n\t\t}};"
                    )
                    toggle_od_name_version(ctx)
                else:
                    toggle_od_name_version(ctx)
                    headerObjDefinitionContent += (
                        f"\t\tstatic constexpr auto get()\n\t\t{{\n"
                        f"\t\t\treturn std::make_tuple(Index, Subindex, OdName, Name, SubIndexName);\n\t\t}}\n\n"
                        f"\t\tstatic constexpr uint8_t Subindex {{{subindex:#04x}}};\n"
                        f"\t\tstatic constexpr std::string_view SubIndexName = \"{subindexName}Subindex\";"
                    )
                    toggle_od_name_version(ctx)
                if params_infos["comment"]:
                    headerObjDefinitionContent += " /*" + params_infos["comment"] + "*/\n"
                    oldHeaderObjDefinitionContent += " /*" + params_infos["comment"] + "*/\n"
                else:
                    headerObjDefinitionContent += "\n"
                    oldHeaderObjDefinitionContent += "\n"
            elif generateSubIndexArrayComment:
                generateSubIndexArrayComment = False
                # Generate Number_of_Entries_sIdx define and write comment
                # about not generating defines for the rest of the array objects
                oldHeaderObjDefinitionContent += (
                    f"#define {RE_NOTW.sub('_', ctx['NodeName'])}"
                    f"_{RE_NOTW.sub('_', ctx['EntryName'])}"
                    f"_{RE_NOTW.sub('_', subentry_infos['name'])}"
                    f"_sIdx {subindex:#04x}\n"
                )
                toggle_od_name_version(ctx)
                headerObjDefinitionContent += (
                    f"\t\tstatic constexpr auto get(uint8_t subIndex)\n\t\t{{\n"
                    f"\t\t\treturn std::make_tuple(Index, subIndex, OdName, Name, \"\");\n\t\t}}\n\n"
                )
                headerObjDefinitionContent += "\t\t/*subindex not generated for array objects*/\n\n"
                toggle_od_name_version(ctx)
                oldHeaderObjDefinitionContent += " /*subindex struct not generated for array objects*/\n\n"
        headerObjDefinitionContent += "\t};\n\n"
    headerObjDefinitionContent += "}\n"

    # --------------------------------------------------------------------------
    #                      Write Header Object Defintions Content
    # --------------------------------------------------------------------------
    file_include_objdef_name = headerfile.replace(".", "_OBJECTDEFINES_").upper()
    headerObjectDefinitionContent = ctx.text(FILE_HEADER)
    headerObjectDefinitionContent += f"""
#ifndef {file_include_objdef_name}
#define {file_include_objdef_name}

/*
    Object defines naming convention:
    General:
        * All characters in object names that does not match [a-zA-Z0-9_] will be replaced by '_'.
        * Case of object dictionary names will be kept as is.
    Index : Node object dictionary name +_+ index name +_+ Idx
    SubIndex : Node object dictionary name +_+ index name +_+ subIndex name +_+ sIdx
*/
"""
    headerObjectDefinitionContent += headerObjDefinitionContent
    headerObjectDefinitionContent += f"\n //---- OLD DEFINES ---- \n\n"
    headerObjectDefinitionContent += oldHeaderObjDefinitionContent
    headerObjectDefinitionContent += f"""
#endif /* {file_include_objdef_name} */
"""

    return str(headerObjectDefinitionContent)


# ------------------------------------------------------------------------------
#                             Main Function
# ------------------------------------------------------------------------------

def GenerateFile(filepath: TPath, node: NodeProtocol, pointers_dict=None):
    """Main function to generate the C file from a object dictionary node."""
    filepath = Path(filepath)
    headerpath = filepath.with_suffix(".h")
    headerdefspath = Path(headerpath.parent / (headerpath.stem + "_objectdefines.h"))
    header_defs = generate_file_content(
        node, headerpath.name, pointers_dict,
    )

    # Write object definitions header
    with open(headerdefspath, "w", encoding="utf-8") as f:
        f.write(header_defs)