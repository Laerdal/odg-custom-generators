"""Generate CPP file containing a modern representation of index/subindex pairs from a object dictionary node for canfestival."""
"""Based on the original gen_cfile.py from odg"""
#
# Copyright (C) 2025-2025  Ronald Kaczynski, Laerdal Medical AS
# Copyright (C): Edouard TISSERANT, Francis DUPIN
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
# USA
#from __future__ import annotations

from pathlib import Path

from objdictgen.maps import OD
from objdictgen.typing import NodeProtocol, TODValue, TPath
from generators_common import *

FILE_HEADER = """
/* File generated by gen_cppfile.py. Should not be modified. */
"""

def generate_file_content(node: NodeProtocol, headerfile: str, pointers_dict=None) -> tuple[str, str, str, str, str]:
    # FIXME: Too many camelCase vars in here
    # pylint: disable=invalid-name

    # Setup the main context to store the data
    ctx, listindex, variablelist = setup_c_file_context(node)

    oldHeaderObjDefinitionContent = ctx.text()
    headerObjDefinitionContent = ctx.text()
    headerObjDefinitionContent += "\n#include <cstdint>\n"
    headerObjDefinitionContent += "#include <tuple>\n"
    headerObjDefinitionContent += "#include <string>\n"
    headerObjDefinitionContent %= """
namespace {NodeName} \n{{
\tstatic constexpr std::string_view OdName = \"{NodeName}\";
"""

    headerObjDefinitionContent %= """
    template<typename T>
    struct Value
    {{
        using DataType = T;
        Value() = default;
        Value(const Value&) = default;
        Value(Value&&) = default;
        Value& operator=(const Value&) = default;
        Value& operator=(Value&&) = default;
        Value(const DataType& value) : m_Value(value) {{}}
        Value(DataType&& value) : m_Value(std::move(value)) {{}}
        Value& operator=(const DataType& value)
        {{
            m_Value = value;
            return *this;
        }}
        Value& operator=(DataType&& value)
        {{
            m_Value = std::move(value);
            return *this;
        }}
        operator const DataType&() const noexcept
        {{
            return m_Value;
        }}
        operator DataType&() noexcept
        {{
            return m_Value;
        }}
    private:
        DataType m_Value{{}};
    }};\n
"""

    for index in listindex:
        ctx["index"] = index
        entry_infos = node.GetEntryInfos(index)
        params_infos = node.GetParamsEntry(index)
        ctx["EntryName"] = entry_infos["name"]
        values = node.GetEntry(index)

        # Entry type is VAR
        if not isinstance(values, list):
            # FIXME: It is assumed that the type of GetParamsEntry() follows the object type
            #        of GetEntry()
            assert not isinstance(params_infos, list)
            subentry_infos = node.GetSubentryInfos(index, 0)
            typename = node.GetTypeName(subentry_infos["type"])
            typeinfos = ctx.get_valid_type_infos(typename, [values])
            if typename == "DOMAIN" and index in variablelist:
                if not typeinfos.size:
                    raise ValueError(f"Domain variable not initialized, index: 0x{index:04X}, subindex: 0x00")
            ctx["subIndexType"] = typeinfos.type
            if typeinfos.size is not None:
                if params_infos["buffer_size"]:
                    ctx["suffix"] = f"[{params_infos['buffer_size']}]"
                else:
                    ctx["suffix"] = f"[{typeinfos.size}]"
            else:
                ctx["suffix"] = ""
            ctx["value"], ctx["comment"] = compute_value(values, typeinfos.ctype)
            if index in variablelist:
                ctx["name"] = RE_STARTS_WITH_DIGIT.sub(r'_\1', format_name(subentry_infos["name"]))
            values = [values]
        else:
            subentry_infos = node.GetSubentryInfos(index, 0)
            typename = node.GetTypeName(subentry_infos["type"])
            typeinfos = ctx.get_valid_type_infos(typename)
            ctx["value"] = values[0] if index != 0x1003 else 0
            ctx["subIndexType"] = typeinfos.type

            # Entry type is ARRAY
            if entry_infos["struct"] & OD.IdenticalSubindexes:
                subentry_infos = node.GetSubentryInfos(index, 1)
                typename = node.GetTypeName(subentry_infos["type"])
                typeinfos = ctx.get_valid_type_infos(typename, values[1:])
                ctx["subIndexType"] = typeinfos.type
                if typeinfos.size is not None:
                    ctx["suffix"] = f"[{typeinfos.size}]"
                    ctx["type_suffix"] = "*"
                else:
                    ctx["suffix"] = ""
                    ctx["type_suffix"] = ""
                ctx["length"] = values[0]
                if index in variablelist:
                    ctx["name"] = RE_STARTS_WITH_DIGIT.sub(r'_\1', format_name(entry_infos["name"]))
                    ctx["values_count"] = str(len(values) - 1)

                ctx["parent"] = RE_STARTS_WITH_DIGIT.sub(r'_\1', format_name(entry_infos["name"]))
                # Entry type is RECORD
                for subindex, value in enumerate(values):
                    ctx["subindex"] = subindex
                    # FIXME: Are there any point in calling this for subindex 0?
                    params_infos = node.GetParamsEntry(index, subindex)
                    # FIXME: Assumed params_info type is coherent with entry_infos["struct"]
                    assert not isinstance(params_infos, list)
                    if subindex > 0:
                        subentry_infos = node.GetSubentryInfos(index, subindex)
                        typename = node.GetTypeName(subentry_infos["type"])
                        typeinfos = ctx.get_valid_type_infos(typename, [values[subindex]])
                        ctx["subIndexType"] = typeinfos.type
                        if typeinfos.size is not None:
                            if params_infos["buffer_size"]:
                                ctx["suffix"] = f"[{params_infos['buffer_size']}]"
                            else:
                                ctx["suffix"] = f"[{typeinfos.size}]"
                        else:
                            ctx["suffix"] = ""
                        ctx["value"], ctx["comment"] = compute_value(value, typeinfos.ctype)
                        ctx["name"] = format_name(subentry_infos["name"])

        # write index define
        entryName = f"{RE_NOTW.sub('', ctx['EntryName']).strip()}"
        shortEntryName = entryName.replace(ctx['EntryName'], '')
        typeinfos = ctx.get_valid_type_infos(typename, [values])
        subindex_type = convert_from_canopen_to_c_type(typeinfos.ctype) if typeinfos.ctype != "visible_string" else "std::string"

        structDeclare = f"\tstruct {entryName}\n\t{{\n"
        if len(values) == 1 or entry_infos["struct"] & OD.IdenticalSubindexes:
            structDeclare = f"\tstruct {entryName} : public Value<{subindex_type}>\n\t{{\n"

        headerObjDefinitionContent += (
            f"{structDeclare}"
            f"\t\tstatic constexpr uint32_t {'' if shortEntryName == entryName else shortEntryName}Index {{{ctx['index']:#04x}}};\n"
            f"\t\tstatic constexpr std::string_view Name = \"{entryName}Index\";\n\n"
        )

        oldHeaderObjDefinitionContent += (
            f"\n#define {RE_NOTW.sub('_', ctx['NodeName'])}"
            f"_{RE_NOTW.sub('_', ctx['EntryName'])}_Idx {ctx['index']:#04x}\n"
        )

        # write subindex defines
        generateSubIndexArrayComment = True
        for subindex, _ in enumerate(values):
            subentry_infos = node.GetSubentryInfos(index, subindex)
            params_infos = node.GetParamsEntry(index, subindex)
            typeinfos = ctx.get_valid_type_infos(typename, [values])
            subindex_type = convert_from_canopen_to_c_type(typeinfos.ctype) if typeinfos.ctype != "visible_string" else "std::string"
            if not entry_infos["struct"] & OD.IdenticalSubindexes:
                generateSubIndexArrayComment = True
                oldHeaderObjDefinitionContent += (
                    f"#define {RE_NOTW.sub('_', ctx['NodeName'])}"
                    f"_{RE_NOTW.sub('_', ctx['EntryName'])}"
                    f"_{RE_NOTW.sub('_', subentry_infos['name'])}"
                    f"_sIdx {subindex:#04x}"
                )
            
                subindexName = RE_NOTW.sub('', subentry_infos['name'])
                if len(values) > 1:
                    headerObjDefinitionContent += (
                        f"\t\tstruct {subindexName}{"Subindex" if subindexName == entryName else ""} : public Value<{subindex_type}>\n"
                        f"\t\t{{\n"
                        f"\t\t\tstatic constexpr auto get()\n\t\t\t{{\n"
                        f"\t\t\t\treturn std::make_tuple(Index, Subindex, OdName, Name, sIdxName);\n\t\t\t}}\n\n"
                        f"\t\t\tstatic constexpr uint32_t Subindex {{{subindex:#04x}}};\n"
                        f"\t\t\tstatic constexpr std::string_view sIdxName = \"{subindexName}Subindex\";"
                        f"\n\t\t}};"
                    )
                else:
                    headerObjDefinitionContent += (
                        f"\t\tstatic constexpr auto get()\n\t\t{{\n"
                        f"\t\t\treturn std::make_tuple(Index, Subindex, OdName, Name, sIdxName);\n\t\t}}\n\n"
                        f"\t\tstatic constexpr uint32_t Subindex {{{subindex:#04x}}};\n"
                        f"\t\tstatic constexpr std::string_view sIdxName = \"{subindexName}Subindex\";"
                    )
                if params_infos["comment"]:
                    headerObjDefinitionContent += " /*" + params_infos["comment"] + "*/\n"
                    oldHeaderObjDefinitionContent += " /*" + params_infos["comment"] + "*/\n"
                else:
                    headerObjDefinitionContent += "\n"
                    oldHeaderObjDefinitionContent += "\n"
            elif generateSubIndexArrayComment:
                generateSubIndexArrayComment = False
                # Generate Number_of_Entries_sIdx define and write comment
                # about not generating defines for the rest of the array objects
                oldHeaderObjDefinitionContent += (
                    f"#define {RE_NOTW.sub('_', ctx['NodeName'])}"
                    f"_{RE_NOTW.sub('_', ctx['EntryName'])}"
                    f"_{RE_NOTW.sub('_', subentry_infos['name'])}"
                    f"_sIdx {subindex:#04x}\n"
                )
                headerObjDefinitionContent += (
                    f"\t\tstatic constexpr auto get()\n\t\t{{\n"
                    f"\t\t\treturn std::make_tuple(Index, Subindex, OdName, Name, sIdxName);\n\t\t}}\n\n"
                    f"\t\tstatic constexpr uint32_t Subindex {{{subindex:#04x}}};\n"
                    f"\t\tstatic constexpr std::string_view sIdxName = \"{subindexName}Subindex\";"
                )

                headerObjDefinitionContent += " /*subindex struct not generated for array objects*/\n\n"
                oldHeaderObjDefinitionContent += " /*subindex struct not generated for array objects*/\n\n"
        headerObjDefinitionContent += "\t};\n\n"
    headerObjDefinitionContent += "}\n"

    # --------------------------------------------------------------------------
    #                      Write Header Object Defintions Content
    # --------------------------------------------------------------------------
    file_include_objdef_name = headerfile.replace(".", "_OBJECTDEFINES_").upper()
    headerObjectDefinitionContent = ctx.text(FILE_HEADER)
    headerObjectDefinitionContent += f"""
#ifndef {file_include_objdef_name}
#define {file_include_objdef_name}

/*
    Object defines naming convention:
    General:
        * All characters in object names that does not match [a-zA-Z0-9_] will be replaced by '_'.
        * Case of object dictionary names will be kept as is.
    Index : Node object dictionary name +_+ index name +_+ Idx
    SubIndex : Node object dictionary name +_+ index name +_+ subIndex name +_+ sIdx
*/
"""
    headerObjectDefinitionContent += headerObjDefinitionContent
    headerObjectDefinitionContent += f"\n //---- OLD DEFINES ---- \n\n"
    headerObjectDefinitionContent += oldHeaderObjDefinitionContent
    headerObjectDefinitionContent += f"""
#endif /* {file_include_objdef_name} */
"""

    return str(headerObjectDefinitionContent)


# ------------------------------------------------------------------------------
#                             Main Function
# ------------------------------------------------------------------------------

def GenerateFile(filepath: TPath, node: NodeProtocol, pointers_dict=None):
    """Main function to generate the C file from a object dictionary node."""
    filepath = Path(filepath)
    headerpath = filepath.with_suffix(".h")
    headerdefspath = Path(headerpath.parent / (headerpath.stem + "_objectdefines.h"))
    header_defs = generate_file_content(
        node, headerpath.name, pointers_dict,
    )

    # Write object definitions header
    with open(headerdefspath, "w", encoding="utf-8") as f:
        f.write(header_defs)